---
title: 前言
---

其实 **编程** 与 **做数学** 是很相似的事情，你知道吗？

相似？

相似到什么程度呢？

> 如果使用合适的语言，两件事其实是一致的。

程序员在写某个 *函数* 以实现某些功能时，首先会想这个函数的输入和输出 *类型* 是什么；
而数学家会把 *命题与猜想* 当作自己的挑战，仔细分析条件，然后努力 *证明* 目标命题。

| 人物   | 问题 | 解答 |
|--------|------|------|
| 程序员 | 类型 | 函数 |
| 数学家 | 命题 | 证明 |

大约在 1934 到 1969 年，数学家和逻辑学家们逐渐发现
[这两件事是一致的！](#curry-howard-correspondence)

> 类型即命题；函数即证明。

数学 *命题* 可以被编码在 *类型* 里；
人们写 *函数* 时所用的语法，其实也是记录 *证明* 中推理步骤的语法；
而编译器做 *类型检查* 的过程，也可以看成是 *辅助证明系统* 检查证明是否正确的过程。

在之后的几十年间，人们以这一发现为指导原则，设计了[一系列形式语言](#辅助证明语言)，
来尝试统一「编程」与「做数学」这两种活动。

然而，作为一名职业程序员，在工作和学习中，
当偶然和伙伴们聊到编程与数学的这一联系时，
大家会感到很惊讶，好像我在吐露着什么玄而又玄的奥秘。

我所做的 [*蝉语*](https://cicada-lang.org)，以及读者面前的这本小册子，
就是想要把个「奥妙的秘密」痛痛快快地吐露给大家。

# 语法设计

在设计语法的时候，我选取了职业程序员所熟悉的语法元素。

因为我认为语法最重要的价值就是为众人所熟悉，
毕竟语言的意义就在于人与人之间的交流，
所以能够促进人们交流的语法设计就是好设计。

下面是一些 *语法示例*，之后会有更详尽的解释，现在给出来只为让读者有个大致印象。

- 总体上，我们贴近世界上最流行的 JavaScript 的语法；
- 用数学家们最熟悉的 `f(x)` 来表示函数作用；
- 用程序员们最熟悉的 `object.method(arg, ...)` 来表示方法调用；
- 我们还采纳了 `function`, `return` 以及 `class` 等程序员所熟悉的语法关键词。

**用模式匹配来定义 *阶乘* 函数：**

``` cicada 印象
function factorial(n: Nat): Nat {
  return induction (n) {
    case zero => one
    case add1(prev, almost) =>
      mul(Nat.add1(prev), almost.prev)
  }
}
```

**用 `class` 来形式化数学结构：**

``` cicada 印象
class Group extends Monoid {
  inv(x: Element): Element

  inv_left(x: Element): Equal(Element, mul(inv(x), x), id)
  inv_right(x: Element): Equal(Element, mul(x, inv(x)), id)

  div(x: Element, y: Element): Element {
    return mul(x, inv(y))
  }
}
```

**用类似 JSON 的语法来构造对象：**

``` cicada 印象
let Person: Type = class {
  name: String,
  city: String,
}

let xyh: Person = {
  name: "谢宇恒",
  city: "银川",
}
```

# 辅佐数学的发展

用计算机软件来辅助数学研究，其实也是很平常的一件事。

2002 年北京的菲尔兹奖（Fields Medal）的主 Vladimir Voevodsky 如是说：

> 假设你想要解某个五次代数方程。
> 通过某些方法，你找到了方程的解，
> 然后你可以把根带入方程中，来检查解是否正确。
>
> 但是当你想要解一个有二十个二十次方程的方程组时，
> 或者想要解类似复杂的问题。
> 通过某些方法，你找到了方程的解，
> 但是此时想要检查解的正确性，就需要做很多计算了。
>
> 如今没人会想用纸和笔来徒手做这类计算了，
> 你会用到某些软件来帮助自己做验证。
>
> 再设想，你的问题是要证明某个定理。
> 你找到的解是一个证明。
> 如何验证证明是否正确呢？
>
> 关于什么才是严格的证明，你从老师或教授那里，学到了一些惯例与原则，
> 但是你还不能把你的证明提供给计算机，让计算机去帮你检查它。

Vladimir Voevodsky 之所以获得 2002 年的菲尔兹奖，是因为他证明了 Milnor 猜想。

他是在 1995 完成初版证明的，却花了 7 年时间才完善了证明，并且获得数学界的认可。

如今，不管是数学证明的过程，还是检查证明的过程，都是漫长的，并且充满了出错的可能。
就像限制程序员只能在纸上写程序一样，
不能运行，也不能测试，从而也不能方便地除错（Debug），
对于熟悉了现代工具的程序员来说，这是不可想象的。

V.V. 的演讲标题为「我是如何开始对数学基础感兴趣的」，感兴趣的读者可以看看完整的演讲记录，
即使略过其中的数学相关的部分，也可以体会到一位世界顶级数学家的心路历程了。

> [演讲记录原文](https://readonly.link/articles/github.com/xieyuheng/inner/-/persons/vladimir-voevodsky/how-i-became-interested-in-foundations-of-mathematics.md)，[我做的中文翻译](https://readonly.link/articles/github.com/xieyuheng/inner/-/translations/zh/how-i-became-interested-in-foundations-of-mathematics.md)。

V.V. 的这个演讲，以及他和他朋友的经历，是激励着我将我的项目坚持下去的重要动力之一。

我想，数学发展的流程中，最基本的「反馈循环 / Feedback loop」非常漫长，有很多可优化的空间。

和 V.V. 一样，我的目标也是：

> 创造一个软件，同时也是一个语言，
> 让所有数学家可以用它完成其工作，让我们的生活更加简单，
> 用软件逐步验证证明中的步骤，以排除我们工作中的不确定性。

# 程序员和数学家相互学习

上文中提到了「测试」与「除错 / Debug」，它们是程序员所熟知的概念。

在软件开发过程中，程序员要保持下面的 *反馈循环* 没有不必要延迟：

> 修改 -> 测试 -> 报告测试结果 -> 修改……

程序员们也是经历了好几代人，才慢慢获得了这些知识，并开发了相关的工具技术。

当我们知道了「编程与做数学是一致的」，就可以把两个领域的知识相互迁移。

又比如，程序员的工作可以分为两部分，首先是实现需求所描述的功能；
其次是维护代码的结构，使其始终处在 *容易理解、容易修改* 的状态，以轻松响应新的需求。

> 如何组织代码，以保持容易修改？

经过好几十年的编程实践，程序员们才摸索出了一些 *原则* 与 *模式*，来部分解答上面的问题。

可以想到，这些知识对于数学界也是很可贵的。

反过来，近代数学的发展，就在于：

> 形成抽象的数学结构，以重用证明。

比如，如果我们对抽象的群证明了某个定理，那么这个定理就适用于所有具体的群。

所以在数学的世界中，充满了各种精美的抽象结构，
可以说，关于「如何做合理的抽象？」，
大概从布尔巴基开始，近代数学积累了一百多年的宝贵经验。

这些知识对于程序员也是极其有价值的，
因为程序员在日常的工作中，无时无刻不在观察问题领域，发现模式并且形成抽象。

类似这样的，程序员和数学家值得相互学习之处，数不胜数。
就像两座美丽的城市通了高铁一样，两座城市变的像是一座更加生机勃勃的大城市了。

# 读者指南

TODO

# 鸣谢

感谢我的家人在这些年来对我的支持和鼓励，
希望这本小册子能让他们更多地了解我这些年的工作。

感谢 Dan Friedman 与 David Christiansen，
我从 Dan 的书 "The Little Schemer" 中学会了编程，
又从 Dan 和 David 的书 "The Little Typer" 中学会了如何实现类型系统。

------

# 注脚

### Curry-Howard correspondence

这种一致性被称作「Curry–Howard 一致性 / Curry–Howard correspondence」。

- 1934 年，Curry 发现了部分逻辑学公理与组合子之间的对应；
- 1969 年，Howard 发现了逻辑中的自然演绎系统与 Lambda 演算之间的对应。

### 辅助证明语言

历史上知名的辅助证明语言有 Automath，Coq，Isabelle，NuPRL，Agda，Idris 以及 Lean。

### 关于编程的实践

关于测试驱动开发，可以参考 Kent Beck 的诸多演讲。

关于面向对象的设计，可以参考 Sandi Metz 的书
"99 Bottles of OOP" 以及 "Practical Object-Oriented Design in Ruby (POODR)"。
